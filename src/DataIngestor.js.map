{"version":3,"file":"DataIngestor.js","sourceRoot":"","sources":["DataIngestor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\n\nexport class DataIngestor{\n    public dataLocation: string;\n    // We can make this setable in future versions if this gets reused.\n    public intermediateResultFilePattern = /^StatisticIntermediateResults_\\d+\\.txt$/;\n    public topologyFilePattern = /^StatisticTraversalTopology_\\d+\\.txt$/\n    public constructor(dataLocation: string){\n        this.dataLocation = dataLocation;\n\n    }\n\n    public read(){\n        const experiments = fs.readdirSync(this.dataLocation);\n        const experimentOutputs: Record<string, IExperimentReadOutput> = {}\n        for (const experiment of experiments){\n            // TODO: Push to final output\n            const experimentOutput = this.readFullExperiment(path.join(this.dataLocation, experiment));\n            experimentOutputs[experiment] = experimentOutput;\n        }\n        return  experimentOutputs;\n    }\n\n    public isDistinctQuery(query: string){\n        return query.includes('DISTINCT');\n    }\n\n    public constructRelevantDocuments(queryPath: string, query: string){\n        const queryRelevantAllInstantiations: string[][][] = [];\n        const files = fs.readdirSync(queryPath)\n            .filter(file => this.intermediateResultFilePattern.test(file));\n        const filterDuplicates = this.isDistinctQuery(query);\n        for (const file of files){\n            const results: Set<string> = new Set();\n            const queryRelevant: string[][] = [];\n\n            const data = fs.readFileSync(path.join(queryPath, file), 'utf-8').trim();\n            const lines = data.split('\\n')\n            if (data.length > 0){\n                for (const line of lines){\n                    const resultData = JSON.parse(line);\n                    if (resultData.operation == 'project'){\n                        if (!filterDuplicates || !results.has(resultData.data)){\n                            results.add(resultData.data);\n                            const prov: string[] = JSON.parse(resultData.provenance);\n                            queryRelevant.push(prov);\n                        }\n                    }\n                }    \n            }\n            queryRelevantAllInstantiations.push(queryRelevant);\n        }\n        return queryRelevantAllInstantiations;\n    }\n    /**\n     * Get topologies in format expected by R3 metric, so as edgelist, \n     * traversal path, and seed documents.\n     * @param queryPath \n     * @param query \n     * @returns \n     */\n    public getTopologies(queryPath: string, query: string){\n        const topologies: ITopologyOutput[] = [];\n        const files = fs.readdirSync(queryPath)\n            .filter(file => this.topologyFilePattern.test(file));\n        for (const file of files){\n            const topology = JSON.parse(fs.readFileSync(path.join(queryPath, file), 'utf-8').trim());\n            // In our case the seed documents are always zero because there is 1 seed document.\n            // Normally you would get seed document for metadata, but the metadata run failed and\n            // time constraints require this 'hack'\n            const seedDocuments = [ 0 ];\n            const edgeList = this.constructEdgeList(topology, 'unweighted');\n            const weightedEdgesInOrder = this.constructEdgesInOrder(topology, 'unweighted');\n            const processedTopology: ITopologyOutput = {\n                edgeList,\n                dereferenceOrder: weightedEdgesInOrder,\n                indexToNode: topology.indexToNodeDict,\n                nodeToIndex: topology.nodeToIndexDict,\n                seedDocuments\n            };\n            topologies.push(processedTopology);\n        }\n        return topologies;\n    }\n\n    /**\n     * This function should work to retrieve seed documents for the returned metadata from Comunica.\n     * @param topology \n     * @returns \n     */\n    public getSeedDocuments(topology: Record<string, any>){\n        const seedDocuments: number[] = [];\n        Object.entries(topology.nodeMetadata).forEach(([key, value]: [string, any]) =>{\n            if (value['seed'] === true){\n                seedDocuments.push(Number(key));\n            }\n        })\n        return seedDocuments\n    }\n\n    public constructEdgeList(topology: any, weightType: 'unweighted' | 'http' | 'documentSize'){\n        const edgeList: number[][] = [];\n        Object.entries(topology.adjacencyListOut).forEach(([key, value]: [string, number[]]) => {\n            for (const target of value){\n                const edge = [Number(key), target, 1];\n                if (weightType === 'http'){\n                    \n                }\n                if (weightType === 'documentSize'){\n                    \n                }\n                edgeList.push(edge);\n            }\n        })\n        return edgeList;\n    }\n\n    public constructEdgesInOrder(topology: any, weightType: 'unweighted' | 'http' | 'documentSize'){\n        return topology.edgesInOrder.map((edge: number[]) => { \n            const weightedEdge = [edge[0], edge[1], 1];\n            if(weightType == 'http'){\n\n            }\n            if(weightType=='documentSize'){\n\n            }\n            return weightedEdge\n        });\n    }\n\n    public readFullExperiment(experimentLocation: string): IExperimentReadOutput{\n        const base64ToDirectory: Record<string, string> = JSON.parse(\n            fs.readFileSync(\n                path.join(experimentLocation, 'base64ToDirectory.json'),\n                'utf-8'\n            )\n        );\n        const templateToRelevantDocuments: Record<string, string[][][][]> = {}; \n        const templateToTopologies: Record<string, ITopologyOutput[][]> = {}\n        Object.entries(base64ToDirectory).forEach(([base64Query, pathToQuery]) => {\n            const query = atob(base64Query);\n            const template = pathToQuery.split(\"/\")[0];\n            templateToRelevantDocuments[template] ??= [];\n            templateToTopologies[template] ??= [];\n            const relevantDocuments: string[][][] = this.constructRelevantDocuments(\n                path.join(experimentLocation, pathToQuery), query\n            );\n            const topologiesQueryInstantiation = this.getTopologies(\n                path.join(experimentLocation, pathToQuery), query\n            );\n            templateToRelevantDocuments[template].push(relevantDocuments);\n            templateToTopologies[template].push(topologiesQueryInstantiation)\n        });\n        return { templateToRelevantDocuments, templateToTopologies }\n    }\n}\n\nexport interface ITopologyOutput{\n    edgeList: number[][];\n    dereferenceOrder: number[][];\n    nodeToIndex: Record<string, number>;\n    indexToNode: Record<number, string>;\n    seedDocuments: number[];\n}\n\nexport interface IExperimentReadOutput{\n    templateToRelevantDocuments: Record<string, string[][][][]>;\n    templateToTopologies: Record<string, ITopologyOutput[][]>;\n}"]}