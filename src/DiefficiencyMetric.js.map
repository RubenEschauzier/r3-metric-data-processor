{"version":3,"file":"DiefficiencyMetric.js","sourceRoot":"","sources":["DiefficiencyMetric.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExperimentReadOutput, IResultTimingsTemplate, ITopologyOutput } from \"./DataIngestor\";\nimport * as di from 'diefficiency';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class DiefficiencyMetricExperiment{\n    public benchmarkData: Record<string, IExperimentReadOutput>;\n\n    public constructor(data: Record<string, IExperimentReadOutput>){\n        this.benchmarkData = data;\n\n    }\n    public async run(): Promise<Record<string, Record<string, ITemplateDieff>>> {\n        const experimentOutputs: Record<string, Record<string, ITemplateDieff>> = {};\n        for (const experiment of Object.keys(this.benchmarkData)){\n            console.log(`Calculating Dieff for ${experiment}`);\n            const templateMetrics = \n                await this.calculateDiEfficiencyExperiment(this.benchmarkData[experiment]);\n            experimentOutputs[experiment] = templateMetrics;\n        }\n        return experimentOutputs;\n    }\n\n    public async calculateDiEfficiencyExperiment(experimentData: IExperimentReadOutput){\n        const relevantDocuments = experimentData.templateToRelevantDocuments;\n        const topologies = experimentData.templateToTopologies;\n        const resultTimestamps = experimentData.templateToTimings;\n        const templateToDiefficiency: Record<string, ITemplateDieff> = {};\n        for (const template of Object.keys(relevantDocuments)){\n            const templateMetrics = await this.calculateDiEfficiencyTemplate(\n                topologies[template], relevantDocuments[template], resultTimestamps[template]\n            );\n            templateToDiefficiency[template] = templateMetrics;\n        }\n        return templateToDiefficiency\n    }\n\n    public async calculateDiEfficiencyTemplate(\n        topologies: ITopologyOutput[][], \n        relevantDocuments: string[][][][],\n        resultTimestamps: IResultTimingsTemplate\n    ): Promise<ITemplateDieff> {\n        const templateRetrievalDieff: IDieffOutput[] = []\n        const templateResultDieff: IDieffOutput[] = [];\n        const templateExecutionTimes: number[] = [];\n        for (let i = 0; i < relevantDocuments.length; i++){\n            // const queryRetrievalDieff: IDieffOutput[] = [];\n            const queryRetrievalTimestamps: number[][] = [];\n            for (let j = 0; j < relevantDocuments[i].length; j++){\n                if (topologies[i][j] === undefined){\n                    console.log(topologies.length)\n                    console.log(topologies[i].length)\n                    console.log(relevantDocuments.length)\n                    console.log(relevantDocuments[i].length)\n                }\n                const relevantDocumentsAsIndex = relevantDocuments[i][j].map(x => {\n                    return x.map(y => {\n                        const indexedNode = topologies[i][j].nodeToIndex[y]\n                        if (indexedNode === undefined){\n                            console.log(topologies[i][j].nodeToIndex)\n                            console.log(`Node: ${y} not in node to index for i,j,y${[i,j,y]}`);\n                        }\n                        return indexedNode\n                    });\n                });\n                // In case there are no relevant documents, the query timed out so diefficiency cant be computed\n                if(relevantDocumentsAsIndex.length > 0){\n                    const timestamps = this.getRetrievalTimestamps(\n                        topologies[i][j],\n                        relevantDocumentsAsIndex,\n                    );\n                    queryRetrievalTimestamps.push(timestamps.zerodEventTimestamps);\n                    // queryRetrievalDieff.push(this.calculateDiEfficiency(\n                    //     timestamps.zerodEventTimestamps, \n                    //     relevantDocumentsAsIndex.length\n                    // ));\n                }\n            }\n            if (queryRetrievalTimestamps.length === 0){\n                templateRetrievalDieff.push({\n                    answerDistributionFunction: [-1],\n                    dieff: -1,\n                    linSpace: [-1]\n                });\n            }\n            else{\n                const averagedTimestamps = this.elementwiseMean(queryRetrievalTimestamps)\n                    .sort(function(a, b){return a-b});\n                const dieffRetrieval = this.calculateDiEfficiency(\n                    averagedTimestamps, \n                    averagedTimestamps.length\n                );\n                templateRetrievalDieff.push(dieffRetrieval);\n            }\n            if (resultTimestamps.timestamps[i][0] == Number.NaN){\n                templateResultDieff.push({answerDistributionFunction: [-1], dieff: -1, linSpace: [-1]});\n                templateExecutionTimes.push(Number.NaN)\n            }\n            else{\n                const dieffResults = this.calculateDiEfficiency(\n                    resultTimestamps.timestamps[i], \n                    resultTimestamps.timestamps[i].length\n                )\n                templateResultDieff.push(dieffResults)\n                const queryTemplateElapsedTimes = resultTimestamps.timeElapsed[i];\n                templateExecutionTimes.push(queryTemplateElapsedTimes\n                    .reduce((acc, val) => acc + val, 0) / queryTemplateElapsedTimes.length\n                );\n            }\n        }\n        return {\n            retrievalDieff: templateRetrievalDieff,\n            resultDieff: templateResultDieff,\n            totalExecutionTime: templateExecutionTimes\n        };\n    }\n\n    public calculateDiEfficiency(timestamps: number[], nResults: number): IDieffOutput{\n        const output = di.DiEfficiencyMetric.answerDistributionFunction(timestamps, 10000)\n        const dieff = di.DiEfficiencyMetric.defAtK(nResults, output.answerDist, output.linSpace)\n       return { answerDistributionFunction: output.answerDist, dieff: dieff, linSpace: output.linSpace}\n    }\n\n    public elementwiseMean(data: number[][]){\n        let maxLenghtArray: number = 0;\n        for (let k = 0; k < data.length; k++){\n            if (data[k].length > maxLenghtArray){\n                maxLenghtArray = data[k].length\n            }\n        }\n        const means: number[] = [];\n        for (let i = 0; i < maxLenghtArray; i++){\n            let totalAtI = 0;\n            let nAtI = 0;\n            for (let j = 0; j < data.length; j++){\n                if (data[j][i]){\n                    totalAtI += data[j][i];\n                    nAtI++;\n                }\n            }\n            means.push(totalAtI/nAtI);\n        }\n        return means;\n    }\n\n    public getRetrievalTimestamps(topology: ITopologyOutput, relevantDocuments: number[][]): IRetrievalTimestamps{\n        const engineTraversalPath = topology.dereferenceOrder\n        // Iterate over engine traversal path, update to visit for result, after update check if new list is empty\n        // if it is empty we have +1 result\n        const eventTimestamps = []\n        const progressUntillResult: Record<number, number[]> = {};\n        for (let i = 0; i < relevantDocuments.length; i++){\n            progressUntillResult[i] = relevantDocuments[i];\n        }\n\n        const traversalUntillAllVisited: number[][] = [];\n        for (let i = 0; i < engineTraversalPath.length; i++){\n            const newVisitedNode = engineTraversalPath[i];\n            traversalUntillAllVisited.push(newVisitedNode);\n            // Edge denotes traversal to second element of edge, so we only check if second element\n            // Is a relevant node\n            for (let j = 0; j < relevantDocuments.length; j++){\n                if (progressUntillResult[j].includes(newVisitedNode[1])){\n                    const nodes = [...progressUntillResult[j]];\n                    // Remove currently found document\n                    nodes.splice(nodes.indexOf(newVisitedNode[1]), 1);\n                    progressUntillResult[j] = nodes;\n                    if (progressUntillResult[j].length === 0){\n                        const nodeMetadata = topology.nodeMetadata[newVisitedNode[1]];\n                        if (nodeMetadata.dereferenceTimestamp){\n                            eventTimestamps.push(nodeMetadata.dereferenceTimestamp);\n                        }\n                        else{\n                            // some instances (like short-4) use the seed document as source\n                            // In this case there is no dereference timestamp (oops), \n                            // but dereference = discover timestamp\n                            eventTimestamps.push(nodeMetadata.discoverTimestamp)\n                        }\n                    }\n                }\n            }\n        }\n        // Zero the timestamps by taking the first discover timestamp as first timestamp\n        let firstDiscoverTimestamp = 0\n        let i = 0;\n        while (firstDiscoverTimestamp === 0){\n            const metadata = topology.nodeMetadata[i];\n            if (metadata.discoverTimestamp){\n                firstDiscoverTimestamp = metadata.discoverTimestamp;\n            }\n            i++;\n        }\n        const zerodEventTimestamps = eventTimestamps.map(x=> x - firstDiscoverTimestamp)\n            .sort(function(a, b){return a-b});\n\n        return { zerodEventTimestamps, firstDiscoverTimestamp };\n    }\n\n    public static writeToFile(data: Record<string, Record<string, ITemplateDieff>>, outputLocation: string){\n        for (const combination of Object.keys(data)){\n            fs.writeFileSync(path.join(outputLocation, `dieff-${combination}.json`), JSON.stringify(data[combination]));\n        }\n    }\n\n}\n\nexport interface IDieffOutput{\n    answerDistributionFunction: number[];\n    linSpace: number[];\n    dieff: number;\n}\n\nexport interface IRetrievalTimestamps{\n    zerodEventTimestamps: number[];\n    firstDiscoverTimestamp: number;\n}\n\nexport interface ITemplateDieff{\n    retrievalDieff: IDieffOutput[];\n    resultDieff: IDieffOutput[];\n    totalExecutionTime: number[];\n}"]}