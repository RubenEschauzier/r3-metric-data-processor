{"version":3,"file":"DiefficiencyMetric.js","sourceRoot":"","sources":["DiefficiencyMetric.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExperimentReadOutput, ITopologyOutput } from \"./DataIngestor\";\nimport * as di from 'diefficiency';\n\nexport class DiefficiencyMetricExperiment{\n    public benchmarkData: Record<string, IExperimentReadOutput>;\n\n    public constructor(data: Record<string, IExperimentReadOutput>){\n        this.benchmarkData = data;\n\n    }\n    public async run(){\n        const experimentOutputs: Record<string, Record<string, number[][]>> = {};\n        for (const experiment of Object.keys(this.benchmarkData)){\n            console.log(`Calculating for ${experiment}`);\n            const templateMetrics = \n                await this.calculateDiEfficiencyExperiment(this.benchmarkData[experiment]);\n            experimentOutputs[experiment] = templateMetrics;\n        }\n        return experimentOutputs;\n    }\n\n    public async calculateDiEfficiencyExperiment(experimentData: IExperimentReadOutput){\n        const relevantDocuments = experimentData.templateToRelevantDocuments;\n        const topologies = experimentData.templateToTopologies;\n        const templateToDiefficiency: Record<string, number[][]> = {};\n        for (const template of Object.keys(relevantDocuments)){\n            console.log(template)\n            const templateMetrics = await this.calculateDiEfficiencyTemplate(\n                topologies[template], relevantDocuments[template]\n            );\n            templateToDiefficiency[template] = templateMetrics;\n        }\n        return templateToDiefficiency\n    }\n\n    public async calculateDiEfficiencyTemplate(topologies: ITopologyOutput[][], relevantDocuments: string[][][][]){\n        const templateMetrics: number[][] = []\n        for (let i = 0; i < relevantDocuments.length; i++){\n            const queryMetrics: number[] = [];\n            for (let j = 0; j < relevantDocuments[i].length; j++){\n                if (topologies[i][j] === undefined){\n                    console.log(topologies.length)\n                    console.log(topologies[i].length)\n                    console.log(relevantDocuments.length)\n                    console.log(relevantDocuments[i].length)\n                }\n                const relevanDocumentsAsIndex = relevantDocuments[i][j].map(x => {\n                    return x.map(y => {\n                        const indexedNode = topologies[i][j].nodeToIndex[y]\n                        if (indexedNode === undefined){\n                            console.log(topologies[i][j].nodeToIndex)\n                            console.log(`Node: ${y} not in node to index for i,j,y${[i,j,y]}`);\n                        }\n                        return indexedNode\n                    });\n                });\n                // In case there are no relevant documents, the query timed out so diefficiency cant be computed\n                if (relevanDocumentsAsIndex.length === 0){\n                    queryMetrics.push(-1);\n                }\n                else{\n                    const timestamps = this.getRetrievalTimestamps(\n                        topologies[i][j],\n                        relevanDocumentsAsIndex,\n                        'event'\n                    );\n                    queryMetrics.push(this.calculateDiEfficiency(timestamps, relevanDocumentsAsIndex.length));    \n                }\n            }\n            templateMetrics.push(queryMetrics);\n        }\n        return templateMetrics;\n    }\n\n    public calculateDiEfficiency(timestamps: number[], nResults: number){\n        const output = di.DiEfficiencyMetric.answerDistributionFunction(timestamps, 1000)\n        const dieff = di.DiEfficiencyMetric.defAtK(nResults, output.answerDist, output.linSpace)\n       return dieff\n    }\n\n    public getRetrievalTimestamps(topology: ITopologyOutput, relevantDocuments: number[][], tsType: 'event' | 'time'){\n        const engineTraversalPath = topology.dereferenceOrder\n        // Iterate over engine traversal path, update to visit for result, after update check if new list is empty\n        // if it is empty we have +1 result\n        const eventTimestamps = []\n        const progressUntillResult: Record<number, number[]> = {};\n        for (let i = 0; i < relevantDocuments.length; i++){\n            progressUntillResult[i] = relevantDocuments[i];\n        }\n\n        const traversalUntillAllVisited: number[][] = [];\n        for (let i = 0; i < engineTraversalPath.length; i++){\n            const newVisitedNode = engineTraversalPath[i];\n            traversalUntillAllVisited.push(newVisitedNode);\n            // Edge denotes traversal to second element of edge, so we only check if second element\n            // Is a relevant node\n            for (let j = 0; j < relevantDocuments.length; j++){\n                if (progressUntillResult[j].includes(newVisitedNode[1])){\n                    const nodes = [...progressUntillResult[j]];\n                    // Remove currently found document\n                    nodes.splice(nodes.indexOf(newVisitedNode[1]), 1);\n                    progressUntillResult[j] = nodes;\n                    if (progressUntillResult[j].length === 0){\n                        if(tsType === 'time'){\n                            // TODO get timestamp from topology dereference metadata and put it in here\n                        }\n                        if (tsType == 'event'){\n                            // At traversal step i have we found a new result\n                            eventTimestamps.push(i);\n                        }\n                    }\n                }\n            }\n        }\n        return eventTimestamps\n    }\n\n    public getAnswerDistribution(retrievalTimestamps: number[]){\n        const distFunction =\n         di.DiEfficiencyMetric.answerDistributionFunction(retrievalTimestamps, 1000);\n        \n    }\n\n    public getResultRetrievalDistribution(){\n\n    }\n}"]}