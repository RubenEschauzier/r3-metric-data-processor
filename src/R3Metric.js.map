{"version":3,"file":"R3Metric.js","sourceRoot":"","sources":["R3Metric.ts"],"names":[],"mappings":"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","sourcesContent":["import * as r3 from 'comunica-experiment-performance-metric';\nimport { IExperimentReadOutput, ITopologyOutput } from './DataIngestor';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class R3Metric{\n    public benchmarkData: Record<string, IExperimentReadOutput>;\n    public metricCalculator: r3.RunLinkTraversalPerformanceMetrics;\n\n    public constructor(data: Record<string, IExperimentReadOutput>){\n        this.benchmarkData = data;\n        this.metricCalculator = new r3.RunLinkTraversalPerformanceMetrics();\n    }\n\n    public async run(){\n        const experimentOutputs: Record<string, Record<string, number[][]>> = {};\n        for (const experiment of Object.keys(this.benchmarkData)){\n            console.log(`Calculating for ${experiment}`);\n            const templateMetrics = \n                await this.calculateMetricExperiment(this.benchmarkData[experiment]);\n            experimentOutputs[experiment] = templateMetrics;\n        }\n        return experimentOutputs;\n    }\n\n    public async calculateMetricExperiment(experimentData: IExperimentReadOutput){\n        const relevantDocuments = experimentData.templateToRelevantDocuments;\n        const topologies = experimentData.templateToTopologies;\n        const templateToR3: Record<string, number[][]> = {};\n        for (const template of Object.keys(relevantDocuments)){\n            console.log(template)\n            const templateMetrics = await this.calculateMetricTemplate(\n                topologies[template], relevantDocuments[template]\n            );\n            templateToR3[template] = templateMetrics;\n        }\n        return templateToR3\n    }\n\n    public async calculateMetricTemplate(topologies: ITopologyOutput[][], relevantDocuments: string[][][][]){\n        const templateMetrics: number[][] = []\n        for (let i = 0; i < relevantDocuments.length; i++){\n            const queryMetricsUnweighted: number[] = [];\n            const queryMetricsWeighted: number[] = [];\n            for (let j = 0; j < relevantDocuments[i].length; j++){\n                if (topologies[i][j] === undefined){\n                    console.log(topologies.length)\n                    console.log(topologies[i].length)\n                    console.log(relevantDocuments.length)\n                    console.log(relevantDocuments[i].length)\n                }\n                const numNodes = Object.keys(topologies[i][j].indexToNode).length;\n                const relevanDocumentsAsIndex = relevantDocuments[i][j].map(x => {\n                    return x.map(y => {\n                        const indexedNode = topologies[i][j].nodeToIndex[y]\n                        if (indexedNode === undefined){\n                            console.log(topologies[i][j].nodeToIndex)\n                            console.log(`Node: ${y} not in node to index for i,j,y${[i,j,y]}`);\n                        }\n                        return indexedNode\n                    });\n                });\n                // In case there are no relevant documents, the query timed out so R3 can't be computed\n                if (relevanDocumentsAsIndex.length === 0){\n                    queryMetricsUnweighted.push(-1);\n                }\n                else{\n                    const output = await this.metricCalculator.runMetricAll(\n                        topologies[i][j].edgeList,\n                        relevanDocumentsAsIndex,\n                        topologies[i][j].dereferenceOrder,\n                        topologies[i][j].seedDocuments,\n                        numNodes\n                    );\n                    queryMetricsUnweighted.push(output);    \n                }\n            }\n            templateMetrics.push(queryMetricsUnweighted);\n        }\n        return templateMetrics;\n    }\n\n    public calculateWeightedR3MetricExperiment(){\n\n    }\n\n    public static writeToFile(data: Record<string, Record<string, number[][]>>, outputLocation: string){\n        for (const combination of Object.keys(data)){\n            fs.writeFileSync(path.join(outputLocation, `r3-${combination}.json`), JSON.stringify(data[combination]))\n        }\n    }\n}"]}